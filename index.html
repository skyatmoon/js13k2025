<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>吸血鬼幸存者小站</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            display: none;
        }
        canvas {
            background-color: #fff;
            display: block;
        }
        #editorContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #characterEditor {
            display: grid;
            grid-template-columns: repeat(5, 30px);
            grid-template-rows: repeat(5, 30px);
            gap: 2px;
        }
        .editorCell {
            width: 30px;
            height: 30px;
            border: 1px solid #666;
            cursor: pointer;
            background-color: #333;
        }
        .editorCell.filled {
            background-color: #000;
        }
        button {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #000;
            color: white;
            border: 2px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #333;
        }
        #scoreDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            background-color: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 3px;
        }
        h1 {
            margin-top: 0;
            color: #fff;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>吸血鬼幸存者 - 角色编辑器</h1>
    <div id="editorContainer">
        <div id="characterEditor">
            <!-- 3x3 编辑器格子将通过JS生成 -->
        </div>
        <button id="startGameBtn">START</button>
    </div>
    
    <div id="gameContainer">
        <div id="scoreDisplay">Score: 0</div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // 全局变量
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const editorContainer = document.getElementById('editorContainer');
        const gameContainer = document.getElementById('gameContainer');
        const startGameBtn = document.getElementById('startGameBtn');
        const characterEditor = document.getElementById('characterEditor');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        // 游戏状态变量
        let isGameOver = false;
        let isGamePaused = false;
        
        // 设置画布尺寸
        canvas.width = 600;
        canvas.height = 600;
        
        // 游戏常量
        const CELL_SIZE = 3;
        const GRID_SIZE = 5; // 修改为5x5网格
        const PLAYER_SIZE = CELL_SIZE * GRID_SIZE;
        const ENEMY_SIZE = 15;
        const PLAYER_SPEED = 2;
        const ENEMY_SPEED_MIN = 0.5;
        const ENEMY_SPEED_MAX = 1.5;
        const INITIAL_ENEMY_COUNT = 5;
        const ENEMY_SPAWN_INTERVAL = 3000; // 毫秒
        const ATTACK_COOLDOWN = 800; // 攻击冷却时间（调整为更容易触发）
        const BULLET_SPEED = 5;
        const BULLET_SIZE = 3;
        const HEART_SIZE = 15;
        const HEART_SPAWN_CHANCE = 0.02; // 2%的概率掉落心形道具
        const INVULNERABILITY_TIME = 3000; // 3秒无敌时间
        const INITIAL_UPGRADE_SCORE = 10; // 第一次升级所需分数
        const UPGRADE_SCORE_MULTIPLIER = 1.2; // 每次升级所需分数的增长倍数
        const INITIAL_ENEMY_LIMIT = 100; // 初始敌人数量上限
        const ENEMY_LIMIT_INCREMENT = 50; // 每次选择MORE_ENEMIES buff时增加的敌人数上限

        // BUFF类型定义
        const BUFF_TYPES = {
            SPEED_BOOST: 'speed_boost',
            FASTER_ATTACK: 'faster_attack',
            STRONGER_BULLETS: 'stronger_bullets',
            MORE_LIVES: 'more_lives',
            FASTER_BULLETS: 'faster_bullets',
            MORE_ENEMIES: 'more_enemies',
            LONGER_INVULNERABILITY: 'longer_invulnerability',
            BETTER_LOOT: 'better_loot',
            MULTI_SHOT: 'multi_shot',
            TRACKING_BULLETS: 'tracking_bullets' // 子弹追踪能力
        };
        
        // 敌人类型定义
        const ENEMY_TYPES = {
            CIRCLE: 'circle',
            SQUARE: 'square',
            TRIANGLE: 'triangle',
            ZIGZAG: 'zigzag',
            SPIRAL: 'spiral'
        };
        
        // 游戏状态
        let player = {
            x: canvas.width / 2 - PLAYER_SIZE / 2,
            y: canvas.height / 2 - PLAYER_SIZE / 2,
            direction: { x: 0, y: 0 },
            characterPattern: Array(GRID_SIZE * GRID_SIZE).fill(false),
            lastAttackTime: 0,
            lives: 3,
            isInvulnerable: false,
            invulnerabilityTimer: 0,
            flashTimer: 0,
            // 用于显示生命值的角色图案（简化版）
            lifeIconPattern: Array(9).fill(false),
            // BUFF相关属性
            speedMultiplier: 1,
            attackSpeedMultiplier: 1,
            bulletDamageMultiplier: 1,
            bulletSpeedMultiplier: 1,
            invulnerabilityTimeMultiplier: 1,
            lootChanceMultiplier: 1,
            multiShotCount: 0,
            enemyLimit: INITIAL_ENEMY_LIMIT, // 当前敌人数量上限
            bulletTrackingTime: 0, // 子弹追踪时间（秒），初始为0
            // 升级相关
            nextUpgradeScore: INITIAL_UPGRADE_SCORE,
            currentUpgradeStep: 1,
            upgrades: []
        };
        
        // 初始化生命图标图案（使用3x3的简化版）
        for (let i = 0; i < 9; i++) {
            // 创建一个简单的角色图标（中心十字形状）
            if (i === 4 || i === 1 || i === 3 || i === 5 || i === 7) {
                player.lifeIconPattern[i] = true;
            }
        }
        
        let enemies = [];
        let bullets = [];
        let hearts = [];
        let score = 0;
        let lastEnemySpawn = 0;
        let keys = {};
        let gameLoopId = null;
        
        // 创建生命值显示元素
        const livesDisplay = document.createElement('div');
        livesDisplay.id = 'livesDisplay';
        livesDisplay.style.position = 'absolute';
        livesDisplay.style.top = '10px';
        livesDisplay.style.right = '10px';
        livesDisplay.style.display = 'flex';
        livesDisplay.style.gap = '5px';
        livesDisplay.style.backgroundColor = 'rgba(0,0,0,0.7)';
        livesDisplay.style.padding = '5px';
        livesDisplay.style.borderRadius = '3px';
        gameContainer.appendChild(livesDisplay);

        // 创建升级界面
        const upgradeScreen = document.createElement('div');
        upgradeScreen.id = 'upgradeScreen';
        upgradeScreen.style.position = 'absolute';
        upgradeScreen.style.top = '50%';
        upgradeScreen.style.left = '50%';
        upgradeScreen.style.transform = 'translate(-50%, -50%)';
        upgradeScreen.style.width = '400px';
        upgradeScreen.style.backgroundColor = 'rgba(0,0,0,0.9)';
        upgradeScreen.style.borderRadius = '10px';
        upgradeScreen.style.padding = '20px';
        upgradeScreen.style.color = 'white';
        upgradeScreen.style.textAlign = 'center';
        upgradeScreen.style.display = 'none';
        upgradeScreen.style.zIndex = '100';
        gameContainer.appendChild(upgradeScreen);

        // 添加升级标题
        const upgradeTitle = document.createElement('h2');
        upgradeTitle.textContent = 'Choose an Upgrade!';
        upgradeTitle.style.marginBottom = '20px';
        upgradeScreen.appendChild(upgradeTitle);

        // 创建升级选项容器
        const upgradeOptions = document.createElement('div');
        upgradeOptions.id = 'upgradeOptions';
        upgradeOptions.style.display = 'flex';
        upgradeOptions.style.flexDirection = 'column';
        upgradeOptions.style.gap = '10px';
        upgradeScreen.appendChild(upgradeOptions);
        
        // 初始化角色编辑器
        function initEditor() {
            // 清空编辑器
            characterEditor.innerHTML = '';
            
            // 默认填充中间格子 (5x5的中心是索引12)
            player.characterPattern[12] = true;
            
            // 创建5x5编辑器格子
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'editorCell';
                if (player.characterPattern[i]) {
                    cell.classList.add('filled');
                }
                cell.dataset.index = i;
                
                cell.addEventListener('click', () => {
                    const index = parseInt(cell.dataset.index);
                    player.characterPattern[index] = !player.characterPattern[index];
                    cell.classList.toggle('filled', player.characterPattern[index]);
                });
                
                characterEditor.appendChild(cell);
            }
        }
        
        // 生成随机升级选项
        function generateUpgradeOptions() {
            const allBuffs = Object.values(BUFF_TYPES);
            const options = [];
            
            // 随机选择3个不同的升级选项
            while (options.length < 3) {
                const randomIndex = Math.floor(Math.random() * allBuffs.length);
                const buffType = allBuffs[randomIndex];
                
                if (!options.includes(buffType)) {
                    options.push(buffType);
                }
            }
            
            return options;
        }
        
        // 获取升级的描述
        function getUpgradeDescription(buffType) {
            switch (buffType) {
                case BUFF_TYPES.SPEED_BOOST:
                    return 'Increase movement speed by 20%';
                case BUFF_TYPES.FASTER_ATTACK:
                    return 'Increase attack speed by 15%';
                case BUFF_TYPES.STRONGER_BULLETS:
                    return 'Increase bullet damage (1 hit kill -> 1 hit kill, just more effect)';
                case BUFF_TYPES.MORE_LIVES:
                    return 'Gain an extra life';
                case BUFF_TYPES.FASTER_BULLETS:
                    return 'Increase bullet speed by 25%';
                case BUFF_TYPES.MORE_ENEMIES:
                    return 'Enemy spawn rate increased, but score gain doubled';
                case BUFF_TYPES.LONGER_INVULNERABILITY:
                    return 'Increase invulnerability time after hit by 50%';
                case BUFF_TYPES.BETTER_LOOT:
                    return 'Increase heart drop chance by 50%';
                case BUFF_TYPES.MULTI_SHOT:
                    return 'Fire multiple bullets at once';
                case BUFF_TYPES.TRACKING_BULLETS:
                    return 'Increase bullet tracking time by 0.2 seconds';
                default:
                    return 'Unknown upgrade';
            }
        }
        
        // 应用升级效果
        function applyUpgrade(buffType) {
            // 记录升级
            player.upgrades.push(buffType);
            
            // 应用升级效果
            switch (buffType) {
                case BUFF_TYPES.SPEED_BOOST:
                    player.speedMultiplier *= 1.2;
                    break;
                case BUFF_TYPES.FASTER_ATTACK:
                    player.attackSpeedMultiplier *= 1.15;
                    break;
                case BUFF_TYPES.STRONGER_BULLETS:
                    player.bulletDamageMultiplier *= 1.5;
                    // 对于当前简单的1-hit kill机制，我们可以让子弹穿透敌人
                    // 在updateBullets函数中处理
                    break;
                case BUFF_TYPES.MORE_LIVES:
                    player.lives++;
                    updateLivesDisplay();
                    break;
                case BUFF_TYPES.FASTER_BULLETS:
                    player.bulletSpeedMultiplier *= 1.25;
                    break;
                case BUFF_TYPES.MORE_ENEMIES:
                    // 增加敌人生成频率，但也增加分数获得
                    // 每次选择此buff，敌人上限增加50个
                    player.enemyLimit += ENEMY_LIMIT_INCREMENT;
                    console.log(`Enemy limit increased to ${player.enemyLimit}`);
                    break;
                case BUFF_TYPES.LONGER_INVULNERABILITY:
                    player.invulnerabilityTimeMultiplier *= 1.5;
                    break;
                case BUFF_TYPES.BETTER_LOOT:
                    player.lootChanceMultiplier *= 1.5;
                    break;
                case BUFF_TYPES.MULTI_SHOT:
                    player.multiShotCount += 1;
                    break;
                case BUFF_TYPES.TRACKING_BULLETS:
                    // 增加子弹追踪时间0.2秒
                    player.bulletTrackingTime += 0.2;
                    console.log(`Bullet tracking time increased to ${player.bulletTrackingTime} seconds`);
                    break;
            }
            
            // 计算下一次升级所需的额外分数（基于当前步骤）
            const baseScore = INITIAL_UPGRADE_SCORE;
            const nextAdditionalScore = Math.ceil(baseScore * Math.pow(UPGRADE_SCORE_MULTIPLIER, player.currentUpgradeStep));
            
            // 设置下一次升级所需的总分阈值（累加）
            player.nextUpgradeScore = score + nextAdditionalScore;
            
            // 增加升级步骤
            player.currentUpgradeStep++;
            
            // 测试用：在控制台打印下一次升级所需信息
            console.log(`Next upgrade at ${player.nextUpgradeScore} (additional ${nextAdditionalScore})`);
        }
        
        // 显示升级界面
        function showUpgradeScreen() {
            // 暂停游戏
            isGamePaused = true;
            
            // 清空之前的选项
            upgradeOptions.innerHTML = '';
             
            // 生成随机升级选项
            const upgradeChoices = generateUpgradeOptions();
             
            // 创建升级选项按钮
            for (const buffType of upgradeChoices) {
                const optionButton = document.createElement('button');
                optionButton.className = 'upgradeOption';
                optionButton.textContent = getUpgradeDescription(buffType);
                optionButton.style.padding = '10px';
                optionButton.style.margin = '5px';
                optionButton.style.backgroundColor = '#444';
                optionButton.style.color = 'white';
                optionButton.style.border = '1px solid #666';
                optionButton.style.borderRadius = '5px';
                optionButton.style.cursor = 'pointer';
                 
                optionButton.addEventListener('click', () => {
                    // 应用选中的升级
                    applyUpgrade(buffType);
                     
                    // 隐藏升级界面
                    upgradeScreen.style.display = 'none';
                     
                    // 继续游戏
                    isGamePaused = false;
                    lastTime = 0; // 重置时间，避免大的时间跳跃
                });
                 
                upgradeOptions.appendChild(optionButton);
            }
             
            // 显示升级界面
            upgradeScreen.style.display = 'block';
        }
        
        // 检查是否需要升级
        function checkForUpgrade() {
            if (score >= player.nextUpgradeScore) {
                showUpgradeScreen();
                return true;
            }
            return false;
        }
        
        // 初始化游戏
        function initGame() {
            // 重置游戏状态
            player.x = canvas.width / 2 - PLAYER_SIZE / 2;
            player.y = canvas.height / 2 - PLAYER_SIZE / 2;
            player.direction = { x: 0, y: 0 };
            player.lastAttackTime = 0;
            player.lives = 3; // 明确设置生命值为3
            // 重置玩家无敌状态相关属性
            player.isInvulnerable = false;
            player.invulnerabilityTimer = 0;
            player.flashTimer = 0;
            enemies = [];
            bullets = [];
            hearts = [];
            score = 0;
            lastEnemySpawn = Date.now();
            
            // 重置升级相关属性
            player.nextUpgradeScore = INITIAL_UPGRADE_SCORE;
            player.currentUpgradeStep = 1;
            player.upgrades = [];
            player.speedMultiplier = 1;
            player.attackSpeedMultiplier = 1;
            player.bulletSpeedMultiplier = 1;
            player.bulletDamageMultiplier = 1;
            player.lootChanceMultiplier = 1;
            player.invulnerabilityTimeMultiplier = 1;
            player.multiShotCount = 0;
            
            // 隐藏升级界面
            upgradeScreen.style.display = 'none';
            
            // 生成初始敌人
            for (let i = 0; i < INITIAL_ENEMY_COUNT; i++) {
                spawnEnemy();
            }
            
            // 更新显示
            updateScore();
            updateLivesDisplay();
        }
        
        // 生成敌人
        function spawnEnemy() {
            // 检查是否已达到敌人数量上限
            if (enemies.length >= player.enemyLimit) {
                return;
            }
            
            // 根据升级调整敌人数量
            const enemyCount = player.upgrades && player.upgrades.includes(BUFF_TYPES.MORE_ENEMIES) ? 2 : 1;
            
            // 确保生成后不超过敌人上限
            const canSpawnCount = Math.min(enemyCount, player.enemyLimit - enemies.length);
            
            for (let i = 0; i < canSpawnCount; i++) {
                let x, y;
                // 确保敌人从屏幕边缘生成
                if (Math.random() < 0.5) {
                    x = Math.random() < 0.5 ? -ENEMY_SIZE : canvas.width;
                    y = Math.random() * canvas.height;
                } else {
                    x = Math.random() * canvas.width;
                    y = Math.random() < 0.5 ? -ENEMY_SIZE : canvas.height;
                }
                
                // 随机选择敌人类型
                const enemyTypes = Object.values(ENEMY_TYPES);
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                
                // 根据类型设置不同的速度和属性
                let speed, amplitude = 0, frequency = 0, rotationAngle = 0;
                
                switch (type) {
                    case ENEMY_TYPES.CIRCLE:
                        speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - ENEMY_SPEED_MIN);
                        break;
                    case ENEMY_TYPES.SQUARE:
                        speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - 0.2 - ENEMY_SPEED_MIN);
                        break;
                    case ENEMY_TYPES.TRIANGLE:
                        speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - 0.3 - ENEMY_SPEED_MIN);
                        break;
                    case ENEMY_TYPES.ZIGZAG:
                        speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - 0.4 - ENEMY_SPEED_MIN);
                        amplitude = 1 + Math.random() * 2; // 随机振幅
                        frequency = 0.02 + Math.random() * 0.03; // 随机频率
                        break;
                    case ENEMY_TYPES.SPIRAL:
                        speed = ENEMY_SPEED_MIN + Math.random() * (ENEMY_SPEED_MAX - 0.5 - ENEMY_SPEED_MIN);
                        rotationAngle = 0;
                        break;
                }
                
                enemies.push({
                    x: x,
                    y: y,
                    size: ENEMY_SIZE,
                    speed: speed,
                    type: type,
                    isHit: false, // 用于受击闪烁效果
                    hitTimer: 0,
                    // 曲线运动相关属性
                    amplitude: amplitude,
                    frequency: frequency,
                    rotationAngle: rotationAngle,
                    movementProgress: 0 // 用于追踪运动进度
                });
            }
        }
        
        // 生成子弹
        function spawnBullet() {
            // 计算子弹初始位置（玩家中心）
            const bulletX = player.x + PLAYER_SIZE / 2 - BULLET_SIZE / 2;
            const bulletY = player.y + PLAYER_SIZE / 2 - BULLET_SIZE / 2;
            
            // 如果有敌人，子弹朝向最近的敌人
            let targetX = 0, targetY = 0;
            let targetEnemy = null;
            
            if (enemies.length > 0) {
                // 找到最近的敌人
                let closestEnemy = enemies[0];
                let closestDistance = Infinity;
                
                for (let enemy of enemies) {
                    const dx = player.x + PLAYER_SIZE/2 - (enemy.x + enemy.size/2);
                    const dy = player.y + PLAYER_SIZE/2 - (enemy.y + enemy.size/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEnemy = enemy;
                    }
                }
                
                // 计算朝向最近敌人的方向
                const dx = closestEnemy.x + closestEnemy.size/2 - (player.x + PLAYER_SIZE/2);
                const dy = closestEnemy.y + closestEnemy.size/2 - (player.y + PLAYER_SIZE/2);
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                targetX = dx / distance;
                targetY = dy / distance;
                targetEnemy = closestEnemy; // 锁定目标敌人
            } else {
                // 没有敌人时，子弹向上发射
                targetX = 0;
                targetY = -1;
            }
            
            bullets.push({
                x: bulletX,
                y: bulletY,
                size: BULLET_SIZE,
                direction: { x: targetX, y: targetY },
                speed: BULLET_SPEED,
                spawnTime: Date.now(), // 记录子弹发射时间
                trackingTime: player.bulletTrackingTime, // 子弹追踪时间
                targetEnemy: targetEnemy // 锁定的目标敌人
            });
        }
        
        // 生成心形道具
        function spawnHeart(x, y) {
            hearts.push({
                x: x,
                y: y,
                size: HEART_SIZE,
                collected: false
            });
        }
        
        // 检查碰撞
        function checkCollision(a, b, sizeA, sizeB) {
            return a.x < b.x + sizeB &&
                   a.x + sizeA > b.x &&
                   a.y < b.y + sizeB &&
                   a.y + sizeA > b.y;
        }
        
        // 更新玩家位置（带时间步长）
        function updatePlayer(deltaTime) {
            // 根据按键更新玩家方向
            player.direction.x = 0;
            player.direction.y = 0;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) player.direction.x = 1;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.direction.x = -1;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) player.direction.y = 1;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) player.direction.y = -1;
            
            // 移动玩家（使用固定时间步长），应用速度升级
            const speedMultiplier = player.speedMultiplier || 1;
            const moveDistance = PLAYER_SPEED * speedMultiplier * (deltaTime / TIME_STEP);
            player.x += player.direction.x * moveDistance;
            player.y += player.direction.y * moveDistance;
            
            // 边界检测
            if (player.x < 0) player.x = 0;
            if (player.x + PLAYER_SIZE > canvas.width) player.x = canvas.width - PLAYER_SIZE;
            if (player.y < 0) player.y = 0;
            if (player.y + PLAYER_SIZE > canvas.height) player.y = canvas.height - PLAYER_SIZE;
            
            // 自动攻击，应用攻击速度升级
            const attackSpeedMultiplier = player.attackSpeedMultiplier || 1;
            const effectiveAttackCooldown = ATTACK_COOLDOWN * attackSpeedMultiplier;
            const now = Date.now();
            if (now - player.lastAttackTime > effectiveAttackCooldown) {
                attack();
                player.lastAttackTime = now;
            }
        }
        
        // 攻击逻辑 - 替换为发射子弹
        function attack() {
            const multiShotCount = player.multiShotCount || 0;
            
            // 如果没有多发射击升级，只发射一颗子弹
            if (multiShotCount === 0) {
                spawnBullet();
                return;
            }
            
            // 有了多发射击升级，发射多颗子弹
            // 每次升级增加2颗额外子弹（均匀分布在圆形）
            const totalBullets = 1 + multiShotCount * 2;
            
            // 发射圆形分布的子弹
            for (let i = 0; i < totalBullets; i++) {
                // 计算每个子弹的角度（均匀分布在360度）
                const angle = (Math.PI * 2 * i) / totalBullets;
                spawnBulletWithOffset(angle);
            }
        }
        
        // 带角度偏移发射子弹
        function spawnBulletWithOffset(angleOffset) {
            // 计算子弹初始位置（玩家中心）
            const bulletX = player.x + PLAYER_SIZE / 2 - BULLET_SIZE / 2;
            const bulletY = player.y + PLAYER_SIZE / 2 - BULLET_SIZE / 2;
            
            // 如果有敌人，子弹朝向最近的敌人
            let targetX = 0, targetY = 0;
            let targetEnemy = null;
            
            if (enemies.length > 0) {
                // 找到最近的敌人
                let closestEnemy = enemies[0];
                let closestDistance = Infinity;
                
                for (let enemy of enemies) {
                    const dx = player.x + PLAYER_SIZE/2 - (enemy.x + enemy.size/2);
                    const dy = player.y + PLAYER_SIZE/2 - (enemy.y + enemy.size/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEnemy = enemy;
                    }
                }
                
                // 计算朝向最近敌人的方向
                const dx = closestEnemy.x + closestEnemy.size/2 - (player.x + PLAYER_SIZE/2);
                const dy = closestEnemy.y + closestEnemy.size/2 - (player.y + PLAYER_SIZE/2);
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // 应用角度偏移
                const originalAngle = Math.atan2(dy, dx);
                const newAngle = originalAngle + angleOffset;
                targetX = Math.cos(newAngle);
                targetY = Math.sin(newAngle);
                targetEnemy = closestEnemy; // 锁定目标敌人
            } else {
                // 没有敌人时，子弹向上发射，应用角度偏移
                const originalAngle = -Math.PI / 2; // 向上
                const newAngle = originalAngle + angleOffset;
                targetX = Math.cos(newAngle);
                targetY = Math.sin(newAngle);
            }
            
            bullets.push({
                x: bulletX,
                y: bulletY,
                size: BULLET_SIZE,
                direction: { x: targetX, y: targetY },
                speed: BULLET_SPEED,
                spawnTime: Date.now(), // 记录子弹发射时间
                trackingTime: player.bulletTrackingTime, // 子弹追踪时间
                targetEnemy: targetEnemy // 锁定的目标敌人
            });
        }
        
        // 更新子弹（带时间步长）
        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // 检查子弹是否在追踪时间内，并且有锁定的目标
                const currentTime = Date.now();
                const bulletAge = (currentTime - bullet.spawnTime) / 1000; // 转换为秒
                
                if (bullet.trackingTime > 0 && bulletAge < bullet.trackingTime && bullet.targetEnemy && enemies.includes(bullet.targetEnemy)) {
                    // 计算子弹到目标敌人的新方向
                    const dx = bullet.targetEnemy.x + bullet.targetEnemy.size/2 - (bullet.x + bullet.size/2);
                    const dy = bullet.targetEnemy.y + bullet.targetEnemy.size/2 - (bullet.y + bullet.size/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance > 0) {
                        // 平滑地改变子弹方向（追踪效果）
                        const smoothFactor = 0.1; // 追踪的平滑因子，值越小转向越平滑
                        bullet.direction.x = bullet.direction.x * (1 - smoothFactor) + (dx / distance) * smoothFactor;
                        bullet.direction.y = bullet.direction.y * (1 - smoothFactor) + (dy / distance) * smoothFactor;
                        
                        // 归一化方向向量
                        const dirLength = Math.sqrt(bullet.direction.x*bullet.direction.x + bullet.direction.y*bullet.direction.y);
                        if (dirLength > 0) {
                            bullet.direction.x /= dirLength;
                            bullet.direction.y /= dirLength;
                        }
                    }
                }
                
                // 移动子弹（使用固定时间步长），应用子弹速度升级
                const bulletSpeedMultiplier = player.bulletSpeedMultiplier || 1;
                const moveDistance = bullet.speed * bulletSpeedMultiplier * (deltaTime / TIME_STEP);
                bullet.x += bullet.direction.x * moveDistance;
                bullet.y += bullet.direction.y * moveDistance;
                
                // 检查子弹是否超出屏幕
                if (bullet.x < -bullet.size || bullet.x > canvas.width ||
                    bullet.y < -bullet.size || bullet.y > canvas.height) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // 检查子弹与敌人的碰撞
                const canPenetrate = player.upgrades && player.upgrades.includes(BUFF_TYPES.STRONGER_BULLETS);
                let hitEnemyCount = 0;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy, bullet.size, enemy.size)) {
                        // 触发敌人受击闪烁
                        enemy.isHit = true;
                        enemy.hitTimer = 3; // 闪烁3帧
                        
                        // 延迟移除敌人，先显示闪烁效果
                        setTimeout(() => {
                            if (enemies.includes(enemy)) {
                                const index = enemies.indexOf(enemy);
                                if (index !== -1) {
                                    enemies.splice(index, 1);
                                    
                                    // 计算分数（应用MORE_ENEMIES升级带来的双倍分数）
                        const baseScore = 1; // 一个敌人一分
                        const scoreMultiplier = player.upgrades && player.upgrades.includes(BUFF_TYPES.MORE_ENEMIES) ? 2 : 1;
                        score += baseScore * scoreMultiplier;
                                    updateScore();
                                    
                                    // 随机生成心形道具，应用BETTER_LOOT升级
                                    const baseDropChance = HEART_SPAWN_CHANCE;
                                    const lootChanceMultiplier = player.lootChanceMultiplier || 1;
                                    const dropChance = baseDropChance * lootChanceMultiplier;
                                    if (Math.random() < dropChance) {
                                        spawnHeart(enemy.x + enemy.size/2 - HEART_SIZE/2, 
                                                   enemy.y + enemy.size/2 - HEART_SIZE/2);
                                    }
                                    
                                    // 有一定概率生成新敌人
                                    if (Math.random() < 0.7) {
                                        spawnEnemy();
                                    }
                                }
                            }
                        }, 100);
                        
                        hitEnemyCount++;
                        
                        // 如果子弹不能穿透，只击中一个敌人后就停止
                        if (!canPenetrate) {
                            break;
                        }
                    }
                }
                
                // 如果子弹击中敌人，且不能穿透，移除子弹
                if (hitEnemyCount > 0 && !canPenetrate) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        // 更新心形道具
        function updateHearts() {
            for (let i = hearts.length - 1; i >= 0; i--) {
                const heart = hearts[i];
                
                // 检查心形道具与玩家的碰撞
                if (checkCollision(player, heart, PLAYER_SIZE, heart.size)) {
                    // 增加生命值
                    player.lives++;
                    updateLivesDisplay();
                    
                    // 移除心形道具
                    hearts.splice(i, 1);
                }
            }
        }
        
        // 更新敌人受击效果
        function updateEnemyHitEffects() {
            for (let enemy of enemies) {
                if (enemy.isHit) {
                    enemy.hitTimer--;
                    if (enemy.hitTimer <= 0) {
                        enemy.isHit = false;
                    }
                }
            }
        }
        
        // 更新生命值显示
        function updateLivesDisplay() {
            // 清空现有图标
            livesDisplay.innerHTML = '';
            
            // 添加Life:标识
            const liveLabel = document.createElement('span');
            liveLabel.textContent = 'Life: ';
            liveLabel.style.marginRight = '5px';
            livesDisplay.appendChild(liveLabel);
            
            // 创建生命值图标（使用用户自定义的角色形象）
            for (let i = 0; i < player.lives; i++) {
                const lifeCanvas = document.createElement('canvas');
                lifeCanvas.width = 20;
                lifeCanvas.height = 20;
                lifeCanvas.style.display = 'inline-block';
                lifeCanvas.style.marginRight = '2px';
                
                const lifeCtx = lifeCanvas.getContext('2d');
                
                // 绘制用户自定义的角色图标
                lifeCtx.fillStyle = '#000';
                const iconCellSize = Math.floor(Math.min(lifeCanvas.width, lifeCanvas.height) / GRID_SIZE);
                const offsetX = (lifeCanvas.width - GRID_SIZE * iconCellSize) / 2;
                const offsetY = (lifeCanvas.height - GRID_SIZE * iconCellSize) / 2;
                
                for (let j = 0; j < GRID_SIZE * GRID_SIZE; j++) {
                    if (player.characterPattern[j]) {
                        const row = Math.floor(j / GRID_SIZE);
                        const col = j % GRID_SIZE;
                        const x = offsetX + col * iconCellSize;
                        const y = offsetY + row * iconCellSize;
                        lifeCtx.fillRect(x, y, iconCellSize, iconCellSize);
                    }
                }
                
                livesDisplay.appendChild(lifeCanvas);
            }
        }
        
        // 更新敌人（带时间步长）
        function updateEnemies(deltaTime) {
            for (let enemy of enemies) {
                // 增加运动进度
                enemy.movementProgress += deltaTime * 0.001;
                
                let moveX = 0, moveY = 0;
                
                // 根据敌人类型使用不同的运动轨迹
                switch (enemy.type) {
                    case ENEMY_TYPES.CIRCLE:
                    case ENEMY_TYPES.SQUARE:
                    case ENEMY_TYPES.TRIANGLE:
                        // 追踪玩家的基本移动
                        const dx = player.x + PLAYER_SIZE/2 - (enemy.x + enemy.size/2);
                        const dy = player.y + PLAYER_SIZE/2 - (enemy.y + enemy.size/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance > 0) {
                            const moveDistance = enemy.speed * (deltaTime / TIME_STEP);
                            moveX = (dx / distance) * moveDistance;
                            moveY = (dy / distance) * moveDistance;
                        }
                        break;
                    
                    case ENEMY_TYPES.ZIGZAG:
                        // 锯齿形移动（追踪玩家的同时左右摆动）
                        const zigzagDx = player.x + PLAYER_SIZE/2 - (enemy.x + enemy.size/2);
                        const zigzagDy = player.y + PLAYER_SIZE/2 - (enemy.y + enemy.size/2);
                        const zigzagDistance = Math.sqrt(zigzagDx*zigzagDx + zigzagDy*zigzagDy);
                        
                        if (zigzagDistance > 0) {
                            // 基础追踪移动
                            const baseMoveDistance = enemy.speed * (deltaTime / TIME_STEP);
                            const baseMoveX = (zigzagDx / zigzagDistance) * baseMoveDistance;
                            const baseMoveY = (zigzagDy / zigzagDistance) * baseMoveDistance;
                            
                            // 计算垂直于追踪方向的摆动
                            const perpendicularX = -baseMoveY;
                            const perpendicularY = baseMoveX;
                            const perpendicularLength = Math.sqrt(perpendicularX*perpendicularX + perpendicularY*perpendicularY);
                            
                            if (perpendicularLength > 0) {
                                const wiggleIntensity = enemy.amplitude * Math.sin(enemy.movementProgress * enemy.frequency);
                                moveX = baseMoveX + (perpendicularX / perpendicularLength) * wiggleIntensity;
                                moveY = baseMoveY + (perpendicularY / perpendicularLength) * wiggleIntensity;
                            } else {
                                moveX = baseMoveX;
                                moveY = baseMoveY;
                            }
                        }
                        break;
                    
                    case ENEMY_TYPES.SPIRAL:
                        // 螺旋形移动
                        enemy.rotationAngle += deltaTime * 0.002 * enemy.speed;
                        const spiralRadius = Math.min(canvas.width, canvas.height) * 0.4;
                        const spiralCenterX = player.x + PLAYER_SIZE/2;
                        const spiralCenterY = player.y + PLAYER_SIZE/2;
                        
                        // 计算螺旋轨迹上的点
                        const t = enemy.movementProgress * 0.5;
                        const spiralX = spiralCenterX + spiralRadius * t * Math.cos(enemy.rotationAngle + t);
                        const spiralY = spiralCenterY + spiralRadius * t * Math.sin(enemy.rotationAngle + t);
                        
                        // 向螺旋轨迹上的点移动
                        const spiralDx = spiralX - (enemy.x + enemy.size/2);
                        const spiralDy = spiralY - (enemy.y + enemy.size/2);
                        const spiralDistance = Math.sqrt(spiralDx*spiralDx + spiralDy*spiralDy);
                        
                        if (spiralDistance > 0) {
                            const moveDistance = enemy.speed * (deltaTime / TIME_STEP);
                            moveX = (spiralDx / spiralDistance) * moveDistance;
                            moveY = (spiralDy / spiralDistance) * moveDistance;
                        }
                        break;
                }
                
                // 应用移动
                enemy.x += moveX;
                enemy.y += moveY;
                
                // 检查敌人与玩家的碰撞
                if (checkCollision(player, enemy, PLAYER_SIZE, enemy.size)) {
                    // 如果玩家不是无敌状态
                    if (!player.isInvulnerable) {
                        // 减少生命值
                        player.lives--;
                        updateLivesDisplay();
                          
                        // 设置玩家无敌状态和闪烁效果
                        player.isInvulnerable = true;
                        const invulnerabilityMultiplier = player.invulnerabilityTimeMultiplier || 1;
                        player.invulnerabilityTimer = INVULNERABILITY_TIME * invulnerabilityMultiplier;
                        player.flashTimer = 0;
                          
                        // 检查游戏是否结束
                        if (player.lives <= 0) {
                            endGame();
                            return;
                        }
                    }
                      
                    // 移除与玩家碰撞的敌人
                    const index = enemies.indexOf(enemy);
                    if (index !== -1) {
                        enemies.splice(index, 1);
                    }
                }
            }
            
            // 定期生成新敌人
            const now = Date.now();
            if (now - lastEnemySpawn > ENEMY_SPAWN_INTERVAL) {
                spawnEnemy();
                lastEnemySpawn = now;
            }
        }
        
        // 更新分数显示
        function updateScore() {
            scoreDisplay.textContent = `得分: ${score}`;
        }
        
        // 绘制玩家
        function drawPlayer() {
            // 如果玩家处于无敌状态，实现闪烁效果
            if (player.isInvulnerable) {
                // 闪烁频率约为每秒10次
                const shouldDraw = Math.floor(player.flashTimer / 100) % 2 === 0;
                if (!shouldDraw) {
                    return; // 不绘制玩家以实现闪烁
                }
                // 设置半透明颜色
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // 半透明黑色
            } else {
                ctx.fillStyle = '#000'; // 正常黑色
            }
            
            // 绘制玩家自定义的5x5模式
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                if (player.characterPattern[i]) {
                    const row = Math.floor(i / GRID_SIZE);
                    const col = i % GRID_SIZE;
                    const x = player.x + col * CELL_SIZE;
                    const y = player.y + row * CELL_SIZE;
                    ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                }
            }
        }
        
        // 绘制敌人
        function drawEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                // 三种不同的灰色调
                const grayLevel = 100 + (i % 3) * 50;
                
                ctx.fillStyle = enemy.isHit ? '#ffffff' : `rgb(${grayLevel}, ${grayLevel}, ${grayLevel})`;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                
                // 根据敌人类型绘制不同形状
                switch (enemy.type) {
                    case ENEMY_TYPES.CIRCLE:
                        // 圆形敌人（原有形状）
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.size/2, enemy.y + enemy.size/2, enemy.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        break;
                         
                    case ENEMY_TYPES.SQUARE:
                        // 方形敌人
                        ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);
                        ctx.strokeRect(enemy.x, enemy.y, enemy.size, enemy.size);
                        break;
                         
                    case ENEMY_TYPES.TRIANGLE:
                        // 三角形敌人
                        ctx.beginPath();
                        ctx.moveTo(enemy.x + enemy.size/2, enemy.y);
                        ctx.lineTo(enemy.x, enemy.y + enemy.size);
                        ctx.lineTo(enemy.x + enemy.size, enemy.y + enemy.size);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                         
                    case ENEMY_TYPES.ZIGZAG:
                        // 锯齿形敌人（六边形表示）
                        const hexagonSize = enemy.size / 2;
                        const hexagonX = enemy.x + hexagonSize;
                        const hexagonY = enemy.y + hexagonSize;
                        ctx.beginPath();
                        for (let j = 0; j < 6; j++) {
                            const angle = (Math.PI / 3) * j;
                            const x = hexagonX + hexagonSize * Math.cos(angle);
                            const y = hexagonY + hexagonSize * Math.sin(angle);
                            if (j === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                         
                    case ENEMY_TYPES.SPIRAL:
                        // 螺旋形敌人（八边形表示）
                        const octagonSize = enemy.size / 2;
                        const octagonX = enemy.x + octagonSize;
                        const octagonY = enemy.y + octagonSize;
                        ctx.beginPath();
                        for (let j = 0; j < 8; j++) {
                            const angle = (Math.PI / 4) * j;
                            const x = octagonX + octagonSize * Math.cos(angle);
                            const y = octagonY + octagonSize * Math.sin(angle);
                            if (j === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                }
                
                // 重置isHit状态
                if (enemy.hitTimer > 0) {
                    enemy.hitTimer--;
                } else {
                    enemy.isHit = false;
                }
            }
        }
        
        // 绘制子弹
        function drawBullets() {
            ctx.fillStyle = '#000'; // 黑色子弹
            for (let bullet of bullets) {
                ctx.fillRect(bullet.x, bullet.y, bullet.size, bullet.size);
            }
        }
        
        // 绘制心形道具
        function drawHearts() {
            ctx.fillStyle = '#ff0000'; // 红色心形
            for (let heart of hearts) {
                // 绘制简单的心形
                const centerX = heart.x + heart.size/2;
                const centerY = heart.y + heart.size/2;
                const size = heart.size/3;
                
                ctx.beginPath();
                // 绘制心形的一半
                ctx.moveTo(centerX, centerY - size);
                ctx.bezierCurveTo(
                    centerX + size*2, centerY - size*2,
                    centerX + size*2, centerY + size,
                    centerX, centerY + size/2
                );
                ctx.bezierCurveTo(
                    centerX - size*2, centerY + size,
                    centerX - size*2, centerY - size*2,
                    centerX, centerY - size
                );
                ctx.fill();
            }
        }
        
        // 固定时间步长和帧率相关变量
        const TIME_STEP = 16; // 约60fps
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS; // 16.67ms per frame
        let lastTime = 0;
        let nextFrameTime = 0;
        
        // 游戏主循环（锁定60fps）
        function gameLoop(timestamp) {
            if (!lastTime) {
                lastTime = timestamp;
                nextFrameTime = timestamp;
            }
             
            // 计算时间差
            const deltaTime = timestamp - lastTime;
             
            // 更新玩家无敌状态计时器（无论是否渲染新帧，都需要更新）
            if (player.isInvulnerable) {
                player.invulnerabilityTimer -= deltaTime;
                player.flashTimer += deltaTime;
                 
                // 如果无敌时间结束，恢复正常状态
                if (player.invulnerabilityTimer <= 0) {
                    player.isInvulnerable = false;
                    player.invulnerabilityTimer = 0;
                    player.flashTimer = 0;
                }
            }
             
            // 检查是否需要升级（仅在游戏运行时）
            if (!isGamePaused && !isGameOver) {
                checkForUpgrade();
            }
             
            // 检查是否应该渲染下一帧
            if (timestamp >= nextFrameTime) {
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                 
                // 更新游戏状态（使用固定的时间步长，仅在游戏未暂停或未结束时）
                if (!isGamePaused && !isGameOver) {
                    // 更新游戏状态
                    updatePlayer(TIME_STEP);
                    updateEnemies(TIME_STEP);
                    updateEnemyHitEffects();
                    updateBullets(TIME_STEP);
                    updateHearts();
                }
                 
                // 绘制游戏元素
                drawPlayer();
                drawEnemies();
                drawBullets();
                drawHearts();
                 
                // 更新时间戳
                lastTime = timestamp;
                 
                // 计算下一帧应该渲染的时间
                nextFrameTime = timestamp + TARGET_FRAME_TIME;
            }
             
            // 继续游戏循环（仅在游戏未结束时）
            if (!isGameOver) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
        
        // 开始游戏
        function startGame() {
            editorContainer.style.display = 'none';
            gameContainer.style.display = 'block';
             
            isGameOver = false;
            isGamePaused = false;
            
            initGame();
            gameLoop();
        }
        
        // 结束游戏
        function endGame() {
            isGameOver = true;
            cancelAnimationFrame(gameLoopId);
             
            // 重置玩家生命值
            player.lives = 3;
             
            // 直接返回开始界面并重新初始化
            gameContainer.style.display = 'none';
            editorContainer.style.display = 'flex';
             
            // 重新初始化编辑器（保留玩家的角色设计）
            initEditor();
        }
        
        // 事件监听
        startGameBtn.addEventListener('click', startGame);
        
        // 键盘事件监听
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // 初始化编辑器
        initEditor();
    </script>
</body>
</html>